#!/usr/bin/env python

from argparse import ArgumentParser
from sys import argv
from time import sleep, time
from subprocess import call
from itertools import count

def xxrange(start, stop=None, step=1):
  i = int(start)
  step=int(step)
  while(stop is None or i <= int(stop)):
    yield i
    i=i+step

def repeat(callback, period=0, max_tries=None, ):
  for i in xxrange(1, max_tries):
    start_time = int(time())
    ret = callback()
    if ret:
      return True
    end_time = int(time())
    sleep_time = max(0.0, period - (end_time - start_time))
    sleep(sleep_time)
  return False

# Victory functions take a command's output.
# If the function returns true, then we should exit the repeat loop.
# If false, then we don't have vicotry and should repeat the cmd.
def until_success_victory(cmd_exit):
  return int(cmd_exit) == 0

def unless_failure_victory(cmd_exit):
  return not (int(cmd_exit) == 0)

def repeat_victory(cmd_exit):
  return False

#repeat [--until-success | --unless-failure] --period PERIOD --max-tries MAX -- command
parser = ArgumentParser(description='A script to convert from one time format to another',)
success_group = parser.add_mutually_exclusive_group()
success_group.add_argument("--until-success", action='store_const', const=until_success_victory, dest="victory_condition")
success_group.add_argument("--unless-failure", action='store_const', const=unless_failure_victory, dest="victory_condition")
parser.add_argument("--period", default=60, type=int)
parser.add_argument("--max-tries", default=10, type=int)
parser.add_argument("cmdargs", type=str, nargs="+")

def main():
  args = parser.parse_args()
  if args.victory_condition is None:
    args.victory_condition = repeat_victory
  def run_program():
    ret_val = call(args.cmdargs)
    return args.victory_condition(ret_val)
  success = repeat(run_program, period=args.period, max_tries=args.max_tries)
  if success:
    exit(0)
  else:
    exit(1)

if __name__ == "__main__":
    main()
